%************************************************
\section{Architettura del progetto}
\label{cap:architettura}
%************************************************

Con questo capitolo ci prenderemo una veloce pausa dalle (poche) nozioni sin qui apprese su CodeIgniter. Più precisamente ci si concentrerà sulle regole per realizzare un buon progetto, anche se la definizione ``regole'' non è forse il termine più corretto, e suona come qualcosa di terribilmente severo e rigido. In informatica si preferisce parlare di ``best practice'', ovvero una raccolta di esperienze significative, raccolte in criteri a cui è bene attenersi per sviluppare un prefissato progetto. Ma perché abbiamo introdotto questo argomento proprio ora che il progetto incominciava ad entrare nel vivo? In realtà, la domanda corretta sarebbe dovuta essere ``perché non si è parlato di ``architettura'' software ben prima!''. Non ci si spaventati comunque, perché molte delle best practice comunemente adottate sono decisamente intuitive da padroneggiare.

\'E importante ora porre l'attenzione sull'analisi di un progetto a prescindere da quale esso sia: un software web o un ponte sopra un fiume, questo non ha alcuna importanza. Uno degli aspetti più sottovalutati è lo studio a monte di un progetto, quello che in ingegneria del software viene comunemente chiamato come ``analisi dei requisiti`` e che costituisce una materia di studio a se stante, rilevante quanto la stessa fase di sviluppo.

Incominciare ad abbozzare un progetto scrivendo direttamente il codice è uno dei peggiori errori che si possa infatti commettere. Soventemente questo entusiasmo si pagherà dovendo rimettere mano al progetto, modificando piccole e continue caratteristiche, se non, nel peggiore dei casi, rincominciando il suo sviluppo da zero. Quindi non ci senta poco professionali se ci si arma di una penna e un block notes per definire con dovizia gli aspetti peculiari del proprio progetto progetto.

\section*{Per chi stiamo sviluppando?}
Domanda banale, ma che influenza direttamente la fase di progettazione. Stiamo sviluppando un software per passione e per mettere alla prova le nostre capacità? Bene, in questo caso, si può affrontare meno rigidamente la fase di progettazione che comunque riveste un ruolo sempre di primo piano: spendete, qualche ora (o giorni per i progetti più complessi) e verrete ripagati da una fase di sviluppo con pochi intoppi, agile e appagante. In caso contrario, non dite che non eravate stati avvisati.

Diversa è la definizione dei requisiti software quando si vuole realizzare un prodotto commerciale commissionato da una azienda. In questo caso sono molti i parametri da tenere in considerazione, e non sempre vale l'equazione che accomuna il ``prodotto con più funzioni'' a ``quanto richiesto dall'azienda''. Vi sembra strano? Non proprio se ci si riflette bene. Un prodotto con molte funzioni è anche più complesso da apprendere per chi ci lavora e questo può portare a dover spendere risorse per addestrare il personale con dispendio di tempo e denaro. Ottimizzare le performance di un software web quando questo non sarà mai posto sotto carico eccessivo, è un altro dispendio inutile di risorse. Insomma, comprendere cosa desidera l'azienda che ci commissiona un lavoro è fondamentale quanto sviluppare un buon codice.

Questo porta ad introdurre il concetto di ``utile'' che talvolta può risultare soggettivo. Il giudizio su alcuni parametri, come la presentazione, l'efficienza o l'usabilità dell'interfaccia, varia a seconda del punto vista degli attori coinvolti (chi utilizza il prodotto). In generale si può affermare che più funzionalità si introducono nel software, maggiore risulterà la sua utilità. \`E però opportuno considerare che una piattaforma di sviluppo e gestione dei contenuti sarà appesantita da funzionalità non strettamente necessarie, andando ad inficiare sulle prestazioni, sull'usabilità dell'interfaccia e sulla riusabilità del codice.

\section*{Analisi dei requisiti}
La definizione degli obiettivi deve essere raggiunta insieme a chi commissiona il lavoro. Esistono molti metodi per individuare i ``requisiti utente'', ovvero le caratteristiche imprescindibili del software rivolte a chi lo utilizzerà. Il metodo più semplice per definirli è l'uso del \emph{linguaggio naturale} con l'end-user, ovvero il cliente finale: insomma, una chiacchierata amichevole, ma puntigliosa permetterà di comprendere chiaramente le specifiche esigenze e le priorità nello sviluppo. Perciò chiedere quali aspetti si dovrebbero introdurre o migliorare, può essere veloce ed efficiente quanto la stesura di diagrammi funzionali tanto comuni nell'ingegneria del software. 

Al termine di questa fase, sarà più facile definire i requisiti funzionali, dove con questo termine si vuole intendere una descrizione accurata delle funzionalità del software, in termini di servizi offerti, di come il sistema reagisce a specifici tipi di input e di come si comporta in situazioni particolari.

Qui viene mostrato un semplice esempio di requisiti funzionali espressi da una ipotetica azienda che si suppone desideri un tool per la catalogazione delle immagini da affiancare alla propria piattaforma editoriale di contenuti web.

\begin{enumerate}
\item il prodotto sviluppato deve risultare indipendente da software proprietari e dalla piattaforma editoriale utilizzata, sia per quanto riguarda la presentazione che le funzionalità annesse. La sua implementazione deve poter essere, in ogni momento esclusa, con impatti nulli sulle funzionalità del software che gestisce i contenuti editoriali;
\item il software deve permettere all'utilizzatore di ``ricercare, catalogare e modificare'' le informazioni sensibili riguardanti le immagini classificate in categorie;
\item requisito fondamentale è l'interoperabilità con la piattaforma editoriale, su cui il progetto deve appoggiarsi soprattutto per la struttura logica con cui vengono gestite le informazioni memorizzate nella base di dati del sito aziendale; 
\item le informazioni sensibili riguardanti le categorie delle immagini devono risultare aggiornabili;
\item l'accesso agli strumenti di editing deve essere concesso ad un utente dotato di relativi permessi (utente administrator);
\item è richiesto il miglioramento della granularità delle operazioni già presenti nella piattaforma editoriale; 
\end{enumerate}

Questo è solo un esempio, che non ha la pretesa di essere esaustivo. Infatti molti punti meriterebbero un approfondimento per definire ulteriori dettagli, come il numero delle categorie, la loro definizione, l'interfaccia utente e molto altro. Definire comunque un primo elenco di requisiti macroscopici per poi realizzarne di nuovi, più specifici e dettagliati è una prassi accettabile.

\section*{Progressive enhancement}
Una volta che si avrà un quadro preciso di cosa si deve sviluppare e in quale modo, saranno chiari anche i tempi e i costi di sviluppo. Nulla vieterà di apportare dei cambiamenti al prodotto (in comune accordo con l'azienda che l'ha commissionato ovviamente), ma qualsiasi intoppo nascerà in seguito, verrà senz'altro mitigato dallo studio condotto nella fase preliminare.

Nonostante tutti gli studi condotti e le buone intenzioni, sarà comunque arduo non commettere qualche errore di progettazione a cui dover poi porre rimedio. Per limitare le correzioni nella fase di sviluppo, ma anche successivamente, si è diffuso in tempi recenti la ``best practice'' definita come ``progressive enhancement''. Secondo questa metodologia di sviluppo, comune alla realizzazione dei software più complessi così come ad una semplice pagina web, si intende comunemente uno sviluppo incrementale del progetto sviluppato, definendo inizialmente le funzioni basilari per poi potenziarle ed estenderle. Questa metodologia non prevede però banalmente solo una progettazione secondo il modello ``top-down'' (dall'alto verso il basso) con cui si formula una visione generale del sistema, senza scendere nello specifico dettaglio delle sue parti. Il progressive enhancement, che comunque molto condivide con il modello top-down, mette in risalto maggiormente la separazione tra l'informazione, di cui fruirà l'utente e la logica (il codice) che è alla base del funzionamento del software. Con questo semplice paradigma è possibile sviluppare un prodotto concentrandosi sulle informazioni prodotte e non sui metodi con cui ottenerle. Sarà sempre possibile in seguito affinare le funzioni del software per renderlo più efficiente e completo.

\section*{Definire gli obiettivi}
\'E giunto il momento di definire i requisiti funzionali del nostro progetto di ``notizie'' che ci vedrà coinvolti. Cosa sappiamo al momento? Poco effettivamente, se non che visualizzeremo una pagina di informazioni prelevate da un database e che potremo definirle e memorizzarle noi stessi tramite una apposita interfaccia gestita da un form. Stendiamo una prima lista:

\label{sec:notizia}
\begin{itemize}
\item realizzare un sito web che sia composto da più sezioni, che in futuro si possano ampliare
\item le sezioni inizialmente previste sono: una pagina principale in cui visualizzare le notizie, una in cui realizzare un form per memorizzarle ed una pagina per essere contattati
\item il sito, inizialmente strutturato in pagine statiche, deve potersi evolvere adottando contenuti dinamici
\item la visualizzazione delle notizie deve essere realizzata mediante una sola pagina principale
\item ogni notizia sarà composta da un titolo, il relativo testo e la data di inserimento.
\item la pagina per l'inserimento sarà composta da appositi moduli per inserire il titolo e il testo dell'informazione. Per il campo data invece verrà automaticamente memorizzata quella di inserimento della notizia, senza alcun intervento da parte dell'utente
\end{itemize}

Definendo una serie di punti che si potranno (e dovranno) sviluppare successivamente con maggiore dovizia di particolari, si rende più chiara l'architettura del progetto con positive ripercussioni sui tempi e sul piacere di svilupparlo. Non c'è niente di più appagante che realizzare un buon codice senza il fastidio di doverci rimettere le mani a più riprese per apportare modifiche non preventivate.

\section{Riepilogo}
Queste regole o accorgimenti risultano probabilmente tediosi e possono essere tralasciati per gettarsi a capofitto nella programmazione. Se il progetto è di piccole dimensioni, come quello di cui ci occuperemo, si può anche correre questo rischio. \'E bene comunque abituarsi a condurre uno studio preventivo ogni volta che ci si appresta a realizzare un software di qualsiasi tipo e dimensione.